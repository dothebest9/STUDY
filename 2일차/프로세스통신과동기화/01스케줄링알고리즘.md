01. Queue

운영체제는 준비 상태의 프로세스와 대기 상태의 프로세스를 관리하기 위해

큐(Queue)자료구조를 사용한다

큐는 선형적으로 데이터를 관리하는 선입선출 형식의 자료구조다.

운영체제는 프로세스의 상태에 따라 구분된 큐를 가지고 있다. 


<img width="762" height="246" alt="image" src="https://github.com/user-attachments/assets/d4ea167e-fc64-43f2-b4fc-252413c75ea4" />


대표적인 큐로는 준비 큐, 대기 큐가 있다.

준비 큐는 CPU를 이용하고 싶은 프로세스들이 줄을 서기 위해 존재하는 큐다.

대기 큐는 입출력 장치를 이용하기 위해 대기 상태에 있는 프로세스들이 줄을 서기위해 존재하는 큐다.

따라서, 프로세스 정보를 가지고 있는 프로세스 컨트롤 블록들이 줄을 서고 

운영체제는 줄 서있는 컨트롤 블록들을 참조해서 어떤 프로세스를 실행할지 결정하게 된다.




![ezgif-164ab0ab7efe41](https://github.com/user-attachments/assets/c0ec38ce-784f-4f2a-ae5d-94b2ad403fd3)

오른쪽에 있는 우선순위가 높은 프로세스가 생기면 준비큐 중간에 새치기를 한다

예를 들면, 프린터를 사용하고 싶은 프로세스들은 프린터 대기큐에서 입출력 작업이 완료되기를 기다린다. 

입출력이 완료되어 완료 인터럽트가 발생되면 운영체제는 대기 큐에서 작업이 완료된 

컨트롤 블록을 준비 상태로 변경한 뒤 준비 큐로 이동시킨다. 

준비 큐에서 대기하다가 본인 순서에 맞게 실행 상태로 전환이 된다.

02. 스케줄링 알고리즘

스케줄링 알고리즘 적용 시, 고려해야할 사항

부하가 최소화 

컴퓨팅 자원을 효율적으로 사용

균형잡힌 스케줄링

대기 및 응답시간이 너무 길면 안됨

03. 알고리즘의 종류

  선입 선출 (First In First Out)

<img width="921" height="312" alt="image" src="https://github.com/user-attachments/assets/d12746af-42b3-492a-8909-63716cadc233" />


단순하고 직관적이지만, 실행 시간이 짧ㅇ느 프로세스가 실행 시간이 긴 프로세스 뒤에서 한참 기다리는 상황이 벌어질수있다

  최단 작업 우선 (Shortest Job First)

<img width="898" height="309" alt="image" src="https://github.com/user-attachments/assets/ebf2c963-f171-44fa-b633-bd1d8e992631" />

무척 단순하고 직관 적이지만, 프로세스의 실행 시간을 정확히 예측할 수 없다는 문제가 있어 현실적이지않다.

  라운드 로빈 (Round Robin)

<img width="1065" height="308" alt="image" src="https://github.com/user-attachments/assets/f13848e1-20cc-4afe-a155-f1598bd1f556" />

정해진 시간 만큼만 CPU를 점유하고, 시간이 다 지나면 컨텍스트 스위칭 하는 방식.

타임 슬라이스의 크기에 따라 성능이 바뀐다 크기가 커지면 프로세스 진행시 입출력 요청반응이 늦어지고 

크기가 작아지면 잦은 컨텍스트 스위칭이 발생하여 성능저하가 된다

  우선순위 스케줄링 (Priority Scheduling)

<img width="1059" height="304" alt="image" src="https://github.com/user-attachments/assets/e13346ce-a608-434f-be12-4581a819ece7" />

우선순위 스케줄링은 앞선 알고리즘들의 기반이 되는 아이디어다. 우선순위만 고려할 경우 

우선순위가 낮은 프로세스가 배제되어 버리는 '기아'상태에 빠질 수 있다.

앞에 알고리즘들도 포함된 알고리즘으로 상위개념이자 기반이다 
